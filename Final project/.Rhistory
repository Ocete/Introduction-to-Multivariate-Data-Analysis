beta_hat[j+1] - qt(1-alpha/2, n-r-1)*sqrt(sigma_hat_square * solve(t(Z)%*%Z)[j+1,j+1]),
',',
beta_hat[j+1] + qt(1-alpha/2, n-r-1)*sqrt(sigma_hat_square * solve(t(Z)%*%Z)[j+1,j+1]),
']', fill=TRUE)
}
#import data
data <- read.table("data/battery.dat")
p <- 5
#set up X
X <- data.matrix(data[,1:p])
n <- length(X[,1])
Z <- c(rep(1,n), X)
Y <- data.matrix(data[,p+1])
names <- c('Z1','Z2','Z3','Z4','Z5')
colnames(Z)<- names
#import data
data <- read.table("data/battery.dat")
p <- 5
#set up X
X <- data.matrix(data[,1:p])
n <- length(X[,1])
Z <- c(rep(1,n), X)
Y <- data.matrix(data[,p+1])
names <- c('','Z1','Z2','Z3','Z4','Z5')
colnames(Z)<- names
Z
X
#import data
data <- read.table("data/battery.dat")
p <- 5
#set up X
X <- data.matrix(data[,1:p])
n <- length(X[,1])
Z <- cbind(rep(1,n), X)
Y <- data.matrix(data[,p+1])
names <- c('','Z1','Z2','Z3','Z4','Z5')
colnames(Z)<- names
sampleMean<-function(X, n) {
Ones <- rep(1,n)
return (1/n * t(X)%*%Ones)
}
sampleCovariance<-function(X, n, sample_mean) {
Ones <- rep(1,n)
return (1/(n-1) * t(X - Ones%*%t(sample_mean))%*%(X - Ones%*%t(sample_mean)))
}
X
Z
# least square estimates
beta_hat <- solve(t(Z)%*%Z)%*%t(Z)%*%Y
beta_hat
# least square estimates
beta_hat <- solve(t(Z)%*%Z)%*%t(Z)%*%Y
rownames(beta_hat) <- c('beta0','beta1','beta2','beta3','beta4','beta5')
beta_hat
# R^2 statistic
R_square <- 1 - sum((Y - Z%*%beta_hat)^2)/sum((Y-mean(Y))^2)
R_square
# sigma_hat_square
sigma_hat_square <- sum((Y - Z%*%beta_hat)^2)/(n-r-1)
cat('Sigma hat square:', sigma_hat_square, fill=TRUE)
# estimated covariance of hat{beta}
covariance_hat <- sigma_hat_square * solve(t(Z)%*%Z)
cat('Covariance Hat:', fill=TRUE)
covariance_hat
# One-at-a-time confidence interval for beta_j
for (j in 0:p) {
cat('Beta hat ', j,': [',
beta_hat[j+1] - qt(1-alpha/2, n-r-1)*sqrt(sigma_hat_square * solve(t(Z)%*%Z)[j+1,j+1]),
',',
beta_hat[j+1] + qt(1-alpha/2, n-r-1)*sqrt(sigma_hat_square * solve(t(Z)%*%Z)[j+1,j+1]),
']', fill=TRUE)
}
# One-at-a-time confidence interval for beta_j
for (j in 0:p) {
cat('Beta hat', j,': [',
beta_hat[j+1] - qt(1-alpha/2, n-r-1)*sqrt(sigma_hat_square * solve(t(Z)%*%Z)[j+1,j+1]),
',',
beta_hat[j+1] + qt(1-alpha/2, n-r-1)*sqrt(sigma_hat_square * solve(t(Z)%*%Z)[j+1,j+1]),
']', fill=TRUE)
}
# confidence region based simultaneous confidence intervals
for (j in 0:p) {
cat('Beta hat', j,': [',
beta_hat[j+1] - sqrt((r+1)*qf(1-alpha, r+1, n-r-1))*sqrt(sigma_hat_square * solve(t(Z)%*%Z)[j+1,j+1]),
',',
beta_hat[j+1] + sqrt((r+1)*qf(1-alpha, r+1, n-r-1))*sqrt(sigma_hat_square * solve(t(Z)%*%Z)[j+1,j+1]),
']', fill=TRUE)
}
# Bonferroni correction based simultaneous confidence intervals
for (j in 0:p) {
cat('Beta hat', j,': [',
beta_hat[j+1] - qt(1-alpha/(2*(r+1)), n-r-1)*sqrt(sigma_hat_square * solve(t(Z)%*%Z)[j+1,j+1]),
',',
beta_hat[j+1] + qt(1-alpha/(2*(r+1)), n-r-1)*sqrt(sigma_hat_square * solve(t(Z)%*%Z)[j+1,j+1]),
']', fill=TRUE)
}
# F-test
# H_0: beta_1 = beta_2 = 0
C <- matrix(c(0,0,1,0,0,1),2,3)
df_1 <- qr(C)$rank # df_1: rank of matrix R
f_stat <- t(C%*%beta_hat)%*%solve(C%*%solve(t(Z)%*%Z)%*%t(C))%*%(C%*%beta_hat)
# confidence interval for z_0^T beta
z01 <- sum(Z[,2])/n
z02 <- sum(Z[,3])/n
z_0 <- c(1, z01, z02)
cat('[',
z_0%*%beta_hat - sqrt(sigma_hat_square)*sqrt(t(z_0)%*%solve(t(Z)%*%Z)%*%z_0)*qt(1-alpha/2, n-r-1),
',',
z_0%*%beta_hat + sqrt(sigma_hat_square)*sqrt(t(z_0)%*%solve(t(Z)%*%Z)%*%z_0)*qt(1-alpha/2, n-r-1),
']')
# confidence interval for z_0^T beta
X_mean <- sampleMean(X,n)
z_0 <- rbind(1, X_mean)
cat('[',
z_0%*%beta_hat - sqrt(sigma_hat_square)*sqrt(t(z_0)%*%solve(t(Z)%*%Z)%*%z_0)*qt(1-alpha/2, n-r-1),
',',
z_0%*%beta_hat + sqrt(sigma_hat_square)*sqrt(t(z_0)%*%solve(t(Z)%*%Z)%*%z_0)*qt(1-alpha/2, n-r-1),
']')
X_mean
z_0
beta_hat
# confidence interval for z_0^T beta
X_mean <- sampleMean(X,n)
z_0 <- rbind(1, X_mean)
cat('[',
t(z_0)%*%beta_hat - sqrt(sigma_hat_square)*sqrt(t(z_0)%*%solve(t(Z)%*%Z)%*%z_0)*qt(1-alpha/2, n-r-1),
',',
t(z_0)%*%beta_hat + sqrt(sigma_hat_square)*sqrt(t(z_0)%*%solve(t(Z)%*%Z)%*%z_0)*qt(1-alpha/2, n-r-1),
']')
# confidence interval for z_0^T beta
X_mean <- sampleMean(X,n)
z_0 <- rbind(1, X_mean)
cat('C.I. for the mean response z_0[',
t(z_0)%*%beta_hat - sqrt(sigma_hat_square)*sqrt(t(z_0)%*%solve(t(Z)%*%Z)%*%z_0)*qt(1-alpha/2, n-r-1),
',',
t(z_0)%*%beta_hat + sqrt(sigma_hat_square)*sqrt(t(z_0)%*%solve(t(Z)%*%Z)%*%z_0)*qt(1-alpha/2, n-r-1),
']')
# prediction interval for Y_0 = z_0^T beta + epsilon_0
cat('[',
z_0%*%beta_hat - sqrt(sigma_hat_square)*sqrt(1+t(z_0)%*%solve(t(Z)%*%Z)%*%z_0)*qt(1-alpha/2, n-r-1),
',',
z_0%*%beta_hat + sqrt(sigma_hat_square)*sqrt(1+t(z_0)%*%solve(t(Z)%*%Z)%*%z_0)*qt(1-alpha/2, n-r-1),
']')
# prediction interval for Y_0 = z_0^T beta + epsilon_0
cat('[',
t(z_0)%*%beta_hat - sqrt(sigma_hat_square)*sqrt(1+t(z_0)%*%solve(t(Z)%*%Z)%*%z_0)*qt(1-alpha/2, n-r-1),
',',
(z_0)%*%beta_hat + sqrt(sigma_hat_square)*sqrt(1+t(z_0)%*%solve(t(Z)%*%Z)%*%z_0)*qt(1-alpha/2, n-r-1),
']')
# prediction interval for Y_0 = z_0^T beta + epsilon_0
cat('[',
t(z_0)%*%beta_hat - sqrt(sigma_hat_square)*sqrt(1+t(z_0)%*%solve(t(Z)%*%Z)%*%z_0)*qt(1-alpha/2, n-r-1),
',',
t(z_0)%*%beta_hat + sqrt(sigma_hat_square)*sqrt(1+t(z_0)%*%solve(t(Z)%*%Z)%*%z_0)*qt(1-alpha/2, n-r-1),
']')
# prediction interval for Y_0 = z_0^T beta + epsilon_0
cat('Prediction interval for Y_0 = z_0^T beta + epsilon_0: [',
t(z_0)%*%beta_hat - sqrt(sigma_hat_square)*sqrt(1+t(z_0)%*%solve(t(Z)%*%Z)%*%z_0)*qt(1-alpha/2, n-r-1),
',',
t(z_0)%*%beta_hat + sqrt(sigma_hat_square)*sqrt(1+t(z_0)%*%solve(t(Z)%*%Z)%*%z_0)*qt(1-alpha/2, n-r-1),
']')
# Confidence Region for (beta_1, beta_2)^T
center <- beta_hat[2:3]
es<-eigen(R%*%solve(t(Z)%*%Z)%*%t(R))
# F-test
# H_0: beta_1 = beta_2 = 0
C <- matrix(c(0,0,1,0,0,1),2,3)
df_1 <- qr(C)$rank # df_1: rank of matrix R
f_stat <- t(C%*%beta_hat)%*%solve(C%*%solve(t(Z)%*%Z)%*%t(C))%*%(C%*%beta_hat)
# F-test
# H_0: beta_1 = beta_2 = 0
betaTest<-function(i_beta, alpha=0.05) {
C <- rep(n,0)
C[i_beta] <- 1
df_1 <- qr(C)$rank # df_1: rank of matrix R
f_stat <- t(C%*%beta_hat)%*%solve(C%*%solve(t(Z)%*%Z)%*%t(C))%*%(C%*%beta_hat)
cval_f <- sigma_hat_square*df_1*qf(1-alpha, 2, n-r-1)
return ('Rejected')
}
for (j in 0:p) {
cat('H_0: Beta ', j,' = 0 --->', betaTest(j),fill=TRUE)
}
# F-test
# H_0: beta_1 = beta_2 = 0
betaTest<-function(i_beta, alpha=0.05) {
C <- rep(p+1,0)
C[i_beta] <- 1
df_1 <- qr(C)$rank # df_1: rank of matrix R
f_stat <- t(C%*%beta_hat)%*%solve(C%*%solve(t(Z)%*%Z)%*%t(C))%*%(C%*%beta_hat)
cval_f <- sigma_hat_square*df_1*qf(1-alpha, 2, n-r-1)
return ('Rejected')
}
for (j in 0:p) {
cat('H_0: Beta ', j,' = 0 --->', betaTest(j),fill=TRUE)
}
C
knitr::opts_chunk$set(echo = TRUE)
library(MASS)
#import data
data <- read.table("data/battery.dat")
p <- 5
#set up X
X <- data.matrix(data[,1:p])
n <- length(X[,1])
Z <- cbind(rep(1,n), X)
Y <- data.matrix(data[,p+1])
names <- c('','Z1','Z2','Z3','Z4','Z5')
colnames(Z)<- names
sampleMean<-function(X, n) {
Ones <- rep(1,n)
return (1/n * t(X)%*%Ones)
}
sampleCovariance<-function(X, n, sample_mean) {
Ones <- rep(1,n)
return (1/(n-1) * t(X - Ones%*%t(sample_mean))%*%(X - Ones%*%t(sample_mean)))
}
# least square estimates
beta_hat <- solve(t(Z)%*%Z)%*%t(Z)%*%Y
rownames(beta_hat) <- c('beta0','beta1','beta2','beta3','beta4','beta5')
beta_hat
# R^2 statistic
R_square <- 1 - sum((Y - Z%*%beta_hat)^2)/sum((Y-mean(Y))^2)
R_square
# sigma_hat_square
sigma_hat_square <- sum((Y - Z%*%beta_hat)^2)/(n-r-1)
knitr::opts_chunk$set(echo = TRUE)
library(MASS)
#import data
data <- read.table("data/battery.dat")
p <- 5
#set up X
X <- data.matrix(data[,1:p])
n <- length(X[,1])
Z <- cbind(rep(1,n), X)
Y <- data.matrix(data[,p+1])
names <- c('','Z1','Z2','Z3','Z4','Z5')
colnames(Z)<- names
sampleMean<-function(X, n) {
Ones <- rep(1,n)
return (1/n * t(X)%*%Ones)
}
sampleCovariance<-function(X, n, sample_mean) {
Ones <- rep(1,n)
return (1/(n-1) * t(X - Ones%*%t(sample_mean))%*%(X - Ones%*%t(sample_mean)))
}
# least square estimates
beta_hat <- solve(t(Z)%*%Z)%*%t(Z)%*%Y
rownames(beta_hat) <- c('beta0','beta1','beta2','beta3','beta4','beta5')
beta_hat
# R^2 statistic
R_square <- 1 - sum((Y - Z%*%beta_hat)^2)/sum((Y-mean(Y))^2)
R_square
# sigma_hat_square
sigma_hat_square <- sum((Y - Z%*%beta_hat)^2)/(n-r-1)
# F-test
# H_0: beta_1 = beta_2 = 0
betaTest<-function(i_beta, alpha=0.05) {
C <- rep(p+1,0)
C[i_beta] <- 1
df_1 <- qr(C)$rank # df_1: rank of matrix R
f_stat <- t(C%*%beta_hat)%*%solve(C%*%solve(t(Z)%*%Z)%*%t(C))%*%(C%*%beta_hat)
cval_f <- sigma_hat_square*df_1*qf(1-alpha, 2, n-r-1)
return ('Rejected')
}
for (j in 0:p) {
cat('H_0: Beta ', j,' = 0 --->', betaTest(j),fill=TRUE)
}
C
C
# sigma_hat_square
sigma_hat_square <- sum((Y - Z%*%beta_hat)^2)/(n-p-1)
cat('Sigma hat square:', sigma_hat_square, fill=TRUE)
# estimated covariance of hat{beta}
covariance_hat <- sigma_hat_square * solve(t(Z)%*%Z)
cat('Covariance Hat:', fill=TRUE)
covariance_hat
# t-test for single coefficient
# H_0: beta_j = 0, H_a: beta_j != 0
j <- 1
t_stat <- (beta_hat[j+1] - 0)/sqrt(sigma_hat_square * solve(t(Z)%*%Z)[j+1,j+1])
t_stat
alpha <- 0.05
cval_t <- qt(1-alpha/2, n-p-1)
cval_t
# One-at-a-time confidence interval for beta_j
for (j in 0:p) {
cat('Beta hat', j,': [',
beta_hat[j+1] - qt(1-alpha/2, n-r-1)*sqrt(sigma_hat_square * solve(t(Z)%*%Z)[j+1,j+1]),
',',
beta_hat[j+1] + qt(1-alpha/2, n-r-1)*sqrt(sigma_hat_square * solve(t(Z)%*%Z)[j+1,j+1]),
']', fill=TRUE)
}
# One-at-a-time confidence interval for beta_j
for (j in 0:p) {
cat('Beta hat', j,': [',
beta_hat[j+1] - qt(1-alpha/2, n-p-1)*sqrt(sigma_hat_square * solve(t(Z)%*%Z)[j+1,j+1]),
',',
beta_hat[j+1] + qt(1-alpha/2, n-p-1)*sqrt(sigma_hat_square * solve(t(Z)%*%Z)[j+1,j+1]),
']', fill=TRUE)
}
# confidence region based simultaneous confidence intervals
for (j in 0:p) {
cat('Beta hat', j,': [',
beta_hat[j+1] - sqrt((r+1)*qf(1-alpha, r+1, n-r-1))*sqrt(sigma_hat_square * solve(t(Z)%*%Z)[j+1,j+1]),
',',
beta_hat[j+1] + sqrt((r+1)*qf(1-alpha, r+1, n-r-1))*sqrt(sigma_hat_square * solve(t(Z)%*%Z)[j+1,j+1]),
']', fill=TRUE)
}
# confidence region based simultaneous confidence intervals
for (j in 0:p) {
cat('Beta hat', j,': [',
beta_hat[j+1] - sqrt((r+1)*qf(1-alpha, r+1, n-p-1))*sqrt(sigma_hat_square * solve(t(Z)%*%Z)[j+1,j+1]),
',',
beta_hat[j+1] + sqrt((r+1)*qf(1-alpha, r+1, n-p-1))*sqrt(sigma_hat_square * solve(t(Z)%*%Z)[j+1,j+1]),
']', fill=TRUE)
}
# confidence region based simultaneous confidence intervals
for (j in 0:p) {
cat('Beta hat', j,': [',
beta_hat[j+1] - sqrt((p+1)*qf(1-alpha, r+1, n-p-1))*sqrt(sigma_hat_square * solve(t(Z)%*%Z)[j+1,j+1]),
',',
beta_hat[j+1] + sqrt((p+1)*qf(1-alpha, r+1, n-p-1))*sqrt(sigma_hat_square * solve(t(Z)%*%Z)[j+1,j+1]),
']', fill=TRUE)
}
# confidence region based simultaneous confidence intervals
for (j in 0:p) {
cat('Beta hat', j,': [',
beta_hat[j+1] - sqrt((p+1)*qf(1-alpha, p+1, n-p-1))*sqrt(sigma_hat_square * solve(t(Z)%*%Z)[j+1,j+1]),
',',
beta_hat[j+1] + sqrt((p+1)*qf(1-alpha, p+1, n-p-1))*sqrt(sigma_hat_square * solve(t(Z)%*%Z)[j+1,j+1]),
']', fill=TRUE)
}
# Bonferroni correction based simultaneous confidence intervals
for (j in 0:p) {
cat('Beta hat', j,': [',
beta_hat[j+1] - qt(1-alpha/(2*(r+1)), n-r-1)*sqrt(sigma_hat_square * solve(t(Z)%*%Z)[j+1,j+1]),
',',
beta_hat[j+1] + qt(1-alpha/(2*(r+1)), n-r-1)*sqrt(sigma_hat_square * solve(t(Z)%*%Z)[j+1,j+1]),
']', fill=TRUE)
}
# Bonferroni correction based simultaneous confidence intervals
for (j in 0:p) {
cat('Beta hat', j,': [',
beta_hat[j+1] - qt(1-alpha/(2*(r+1)), n-p-1)*sqrt(sigma_hat_square * solve(t(Z)%*%Z)[j+1,j+1]),
',',
beta_hat[j+1] + qt(1-alpha/(2*(r+1)), n-p-1)*sqrt(sigma_hat_square * solve(t(Z)%*%Z)[j+1,j+1]),
']', fill=TRUE)
}
# Bonferroni correction based simultaneous confidence intervals
for (j in 0:p) {
cat('Beta hat', j,': [',
beta_hat[j+1] - qt(1-alpha/(2*(p+1)), n-p-1)*sqrt(sigma_hat_square * solve(t(Z)%*%Z)[j+1,j+1]),
',',
beta_hat[j+1] + qt(1-alpha/(2*(p+1)), n-p-1)*sqrt(sigma_hat_square * solve(t(Z)%*%Z)[j+1,j+1]),
']', fill=TRUE)
}
# F-test
# H_0: beta_1 = beta_2 = 0
betaTest<-function(i_beta, alpha=0.05) {
C <- rep(p+1,0)
C[i_beta] <- 1
df_1 <- qr(C)$rank # df_1: rank of matrix R
f_stat <- t(C%*%beta_hat)%*%solve(C%*%solve(t(Z)%*%Z)%*%t(C))%*%(C%*%beta_hat)
cval_f <- sigma_hat_square*df_1*qf(1-alpha, 2, n-r-1)
return ('Rejected')
}
for (j in 0:p) {
cat('H_0: Beta ', j,' = 0 --->', betaTest(j),fill=TRUE)
}
C
rep(p+1,1)
rep(p+1,1)
# F-test
# H_0: beta_1 = beta_2 = 0
betaTest<-function(i_beta, alpha=0.05) {
C <- rep(0, p+1)
C[i_beta] <- 1
df_1 <- qr(C)$rank # df_1: rank of matrix R
f_stat <- t(C%*%beta_hat)%*%solve(C%*%solve(t(Z)%*%Z)%*%t(C))%*%(C%*%beta_hat)
cval_f <- sigma_hat_square*df_1*qf(1-alpha, 2, n-r-1)
return ('Rejected')
}
for (j in 0:p) {
cat('H_0: Beta ', j,' = 0 --->', betaTest(j),fill=TRUE)
}
C
C <- rep(0, p+1)
C
C[i_beta] <- 1
C[2] <- 1
C
# F-test
# H_0: beta_1 = beta_2 = 0
betaTest<-function(i_beta, alpha=0.05) {
C <- rep(0, p+1)
C[i_beta] <- 1
df_1 <- qr(C)$rank # df_1: rank of matrix R
f_stat <- t(C%*%beta_hat)%*%solve(C%*%solve(t(Z)%*%Z)%*%t(C))%*%(C%*%beta_hat)
cval_f <- sigma_hat_square*df_1*qf(1-alpha, 2, n-r-1)
return ('Rejected')
}
for (j in 0:p) {
cat('H_0: Beta ', j,' = 0 --->', betaTest(j),fill=TRUE)
}
qr(C)$rank
solve(t(Z) %*% Z)
C
# F-test
# H_0: beta_1 = beta_2 = 0
betaTest<-function(i_beta, alpha=0.05) {
C <- cbind(rep(0, p+1))
C[,i_beta] <- 1
df_1 <- qr(C)$rank # df_1: rank of matrix R
f_stat <- t(C%*%beta_hat)%*%solve(C%*%solve(t(Z)%*%Z)%*%t(C))%*%(C%*%beta_hat)
cval_f <- sigma_hat_square*df_1*qf(1-alpha, 2, n-r-1)
return ('Rejected')
}
for (j in 0:p) {
cat('H_0: Beta ', j,' = 0 --->', betaTest(j),fill=TRUE)
}
# F-test
# H_0: beta_1 = beta_2 = 0
betaTest<-function(i_beta, alpha=0.05) {
C <- rep(0, p+1)
C[i_beta] <- 1
df_1 <- qr(C)$rank # df_1: rank of matrix R
f_stat <- t(C%*%beta_hat)%*%solve(C%*%solve(t(Z)%*%Z)%*%t(C))%*%(C%*%beta_hat)
cval_f <- sigma_hat_square*df_1*qf(1-alpha, 2, n-r-1)
return ('Rejected')
}
for (j in 0:p) {
cat('H_0: Beta ', j,' = 0 --->', betaTest(j),fill=TRUE)
}
# F-test
# H_0: beta_1 = beta_2 = 0
betaTest<-function(i_beta, alpha=0.05) {
C <- rep(0, p+1)
C[i_beta] <- 1
df_1 <- qr(C)$rank # df_1: rank of matrix R
f_stat <- t(C%*%beta_hat)%*%solve(t(C)%*%solve(t(Z)%*%Z)%*%C)%*%(C%*%beta_hat)
cval_f <- sigma_hat_square*df_1*qf(1-alpha, 2, n-r-1)
return ('Rejected')
}
for (j in 0:p) {
cat('H_0: Beta ', j,' = 0 --->', betaTest(j),fill=TRUE)
}
# F-test
# H_0: beta_1 = beta_2 = 0
betaTest<-function(i_beta, alpha=0.05) {
C <- rep(0, p+1)
C[i_beta] <- 1
df_1 <- qr(C)$rank # df_1: rank of matrix R
f_stat <- t(C%*%beta_hat)%*%solve(C%*%solve(t(Z)%*%Z)%*%t(C))%*%(C%*%beta_hat)
cval_f <- sigma_hat_square*df_1*qf(1-alpha, 2, n-r-1)
return ('Rejected')
}
for (j in 0:p) {
cat('H_0: Beta ', j,' = 0 --->', betaTest(j),fill=TRUE)
}
# prediction interval for Y_0 = z_0^T beta + epsilon_0
cat('Prediction interval for Y_0 = z_0^T beta + epsilon_0: [',
t(z_0)%*%beta_hat - sqrt(sigma_hat_square)*sqrt(1+t(z_0)%*%solve(t(Z)%*%Z)%*%z_0)*qt(1-alpha/2, n-p-1),
',',
t(z_0)%*%beta_hat + sqrt(sigma_hat_square)*sqrt(1+t(z_0)%*%solve(t(Z)%*%Z)%*%z_0)*qt(1-alpha/2, n-p-1),
']')
# confidence interval for z_0^T beta
X_mean <- sampleMean(X,n)
z_0 <- rbind(1, X_mean)
cat('C.I. for the mean response z_0[',
t(z_0)%*%beta_hat - sqrt(sigma_hat_square)*sqrt(t(z_0)%*%solve(t(Z)%*%Z)%*%z_0)*qt(1-alpha/2, n-p-1),
',',
t(z_0)%*%beta_hat + sqrt(sigma_hat_square)*sqrt(t(z_0)%*%solve(t(Z)%*%Z)%*%z_0)*qt(1-alpha/2, n-p-1),
']')
# prediction interval for Y_0 = z_0^T beta + epsilon_0
cat('Prediction interval for Y_0 = z_0^T beta + epsilon_0: [',
t(z_0)%*%beta_hat - sqrt(sigma_hat_square)*sqrt(1+t(z_0)%*%solve(t(Z)%*%Z)%*%z_0)*qt(1-alpha/2, n-p-1),
',',
t(z_0)%*%beta_hat + sqrt(sigma_hat_square)*sqrt(1+t(z_0)%*%solve(t(Z)%*%Z)%*%z_0)*qt(1-alpha/2, n-p-1),
']')
# F-test
# H_0: beta_1 = beta_2 = 0
C <- matrix(c(0,0,1,0,0,1),2,3)
df_1 <- qr(C)$rank # df_1: rank of matrix R
f_stat <- t(C%*%beta_hat)%*%solve(C%*%solve(t(Z)%*%Z)%*%t(C))%*%(C%*%beta_hat)
C
class(identity)
identity(identity)
diag(p)
# F-test
# H_0: beta_1 = beta_2 = 0
C <- cbind(rep(0,p), diag(p))
df_1 <- qr(C)$rank # df_1: rank of matrix R
f_stat <- t(C%*%beta_hat)%*%solve(C%*%solve(t(Z)%*%Z)%*%t(C))%*%(C%*%beta_hat)
f_stat
cval_f <- sigma_hat_square*df_1*qf(1-alpha, 2, n-r-1)
C
# F-test
# H_0: beta_1 = beta_2 = 0
C <- cbind(rep(0,p), diag(p))
df_1 <- qr(C)$rank # df_1: rank of matrix R
f_stat <- t(C%*%beta_hat)%*%solve(C%*%solve(t(Z)%*%Z)%*%t(C))%*%(C%*%beta_hat)
f_stat
cval_f <- sigma_hat_square*df_1*qf(1-alpha, 2, n-p-1)
cval_f
# (equivalent) F-test by comparing residuals
# fit the reduced model
beta_hat_reduced <- solve(t(Z[,1])%*%Z[,1])%*%t(Z[,1])%*%Y
beta_hat_reduced
f_stat_reduced <- ((sum((Y - Z[,1]%*%beta_hat_reduced)^2) - sum((Y - Z%*%beta_hat)^2))/2)/sigma_hat_square
f_stat_reduced
Z[,1]
Z
